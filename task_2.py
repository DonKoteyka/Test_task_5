# Возможно это будет интересно, у меня уже была для реализации LIFO в домашнем задании
# https://github.com/DonKoteyka/AD_HW7/blob/main/main.py
# само условие задания https://github.com/netology-code/py-homeworks-advanced/tree/master/7.Interview



class BufferLim:
    """
    класс создающий буфер с фиксированным объёмом
    приемущества: использует фиксированное количество памяти, имеют постоянную (O(1)) сложность времени, позволяет переиспользовать память
    недостатки: имеет жёсткую архитектуру, невозможность корретирования уже попавших в буфер данных, по сути работающую как "циркуляция" данных (FIFO),
    (что может быть использовано как достоинство в плане безопасности),
    размер буфера фиксирован, что вносит ограничения по расширению (но может быть реализовано добавлением соответствующей функции), 
    в текущем исполнении для увеличения объёма нужно создать новый буфер большего объёма
    
    """
    def __init__(self, size):
        """
        создаём буфер определённого размера
        """
        self.size = size
        self.buffer = list([None for _ in range(self.size)])

    def __str__(self):
        """ 
        выводим буфер в человекочитаемый вид
        """
        return str(self.buffer)
    
    def run(self, item: str|int) -> None|str|int:
        """
        заполняем буфер, 
        если буфер не заполнен, то просто добавляем элементы возвращая None
        если буфер заполнен,то производим циркуляцию элементов (добавля элемент в конец и возвращая элемент "сверху стопки")
        """
        cash_back = self.buffer.pop(0)
        self.buffer.append(item)
        return cash_back

    def read(self):
        """
        метода производит чтение первого элемента из буфера, без его удаления
        """
        return self.buffer[0]
    def check(self) -> int:
        return self.buffer.count(None)

    def state(self) -> str:
        """
        вывод заполнености буфера в консоль
        """
        full = self.size - self.check()
        return f'Буфер заполнен на {full}/{self.size}'
    
    def purge(self) -> None:
        """
        полная очистка буфера, без изменения его размера
        """
        self.buffer = list([None for _ in range(self.size)])


class BufferUnlim:
    """
    класс создающий буфер с динамическим объёмом
    приемущества: имеют постоянную (O(1)) сложность времени, позволяет расширять буфер без его пересоздания
    недостатки: невозможность корретирования уже попавших в буфер данных, по сути работающую как "циркуляция" данных (FIFO),
    (что может быть использовано как достоинство в плане безопасности), 
    объём буфера необходимо контролировать в "ручном режиме", может занимать большой объём памяти 
        
    """
    def __init__(self):
        """
        создаём буфер 
        """
        self.buffer = list()

    def __str__(self) -> str: 
        """ 
        выводим буфер в человекочитаемый вид
        """
        return str(self.buffer)
    
    def add(self, item: str|int) -> None:
        """
        добавление элементов в конец буфера, с расширением буфера
        """
        self.buffer.append(item)

    def exp(self) -> str|int|None:
        """
        извлечение элементов из буфера, при условии что там есть хотябы 2 элемента
        """
        if len(self.buffer) >= 2:
            return self.buffer.pop(0)

    def read(self):
        """
        метода производит чтение первого элемента из буфера, без его удаления
        """
        return self.buffer[0]
    
    def run(self, item: str|int) -> None|str|int:
        """
        если буфер имеет хотя бы 2 элемента,то производим циркуляцию элементов (добавля элемент в конец и возвращая элемент "сверху стопки")
        если условие не выполняется, элементы просто добавляются в конец
        """
        cash_back = self.exp()
        self.add(item)
        return cash_back
    
    def state(self) -> str:
        """
        вывод количества элементов буфера в консоль
        """
        return f'В буфере {len(self.buffer)} элементов'
    
    def purge(self) -> None:
        """
        полная очистка буфера
        """
        self.buffer = list()


if __name__ == "__main__":
    buffer = BufferUnlim()
    # buffer = BufferLim(3)
    buffer.add("1111")
    buffer.add("222")
    buffer.add("3")
    print(buffer)
    buffer.run("4444")
    buffer.run("55555")
    print(buffer)

